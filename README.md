# Simple Mark-and-Sweep Garbage Collector in C

A lightweight, portable mark-and-sweep garbage collector implemented in C.  
Supports **x86 (32 & 64-bit)** and **ARM (32 & 64-bit)** architectures.  

This library provides automatic memory management for C programs, scanning memory regions such as the stack, heap, data, and BSS sections. It also supports register scanning on supported architectures.

## Features

- Portable across x86 and ARM, both 32-bit and 64-bit.
- Automatic memory management with `gc_collect()`.
- Configurable memory scanning options.
- Exposes both **static (`libgc.a`)** and **shared (`libgc.so`)** libraries.
- Simple API to allocate, free, and manage memory with garbage collection.


## Tested Platforms

The table below summarizes the operating systems and architectures on which this garbage collector has been tested:

| OS / Architecture | x86 32-bit | x86 64-bit | ARM 32-bit | ARM 64-bit |
|------------------|------------|------------|------------|------------|
| Linux            | ✅         | ✅         | ✅         | ✅         |
| macOS            | ❌         | ❌         | ❌         | ✅         |
| Windows          | ❌         | ❌         | ❌         | ❌         |

**Note:** Other platforms may work but have not been tested. Use at your own discretion.

## Installation

Clone this repository and build using the provided `Makefile`:

````bash
git clone https://github.com/valerio-afk/gc.git
cd gc
make
````

### Optional Flags

* `ARCH=32` or `ARCH=64` — force compilation for a specific architecture.
* `DEBUG=1` — enable debug mode (-g -O0 -DDEBUG), otherwise optimized (-O3).

To propertly run the test executable generated by the Makefile, it is recommended to use `DEBUG=1`.

## Usage

To include this garbage collector in your program, you need to:

* Include the header file in your project
````c
#include "gc.h"
````

* Initialise the garbage collector (first thing in your main):

````c
gc_state* state = gc_init(GC_SCAN_ALL_MEMORY_EXCEPT_HEAPS);

````

* Then start allocating memory (anywhere in your code):

````c
int* arr = gc_alloc(state, 100 * sizeof(int), true); 
````

* Free the state of the garbage collector (last line of your main before return):

````c
gc_destroy(state);
````


## Documentation

### Initialisation flags

The flag(s) used for the initialisation specify what memory areas the garbage collector should scan to find reachable pointers. These are the supported flags:

| Flag | Description |
|------|-------------|
| `GC_SCAN_STACK` | Scan the stack for reachable pointers. |
| `GC_SCAN_HEAPS` | Scan all heap allocations. |
| `GC_SCAN_DATA_SECTION` | Scan the .data section. |
| `GC_SCAN_BSS_SECTION` | Scan the .bss section. |
| `GC_SCAN_REGISTERS` | Scan CPU registers (supported architectures only). |
| `GC_SCAN_ALL_GLOBALS` | .data + .bss sections. |
| `GC_SCAN_ALL_MEMORY` | Stack + heaps + global sections. |
| `GC_SCAN_EVERYTHING` | All memory + registers. |
| `GC_SCAN_ALL_MEMORY_EXCEPT_HEAPS` | Stack + global sections. |
| `GC_SCAN_EVERYTHING_EXCEPT_HEAPS` | Similar to `GC_SCAN_EVERYTHING`, but heaps are not scanned |

#### Notes
* In most platforms, the stdlib of C may allocate other areas of the memory for the heap memory, especially when a lot of memory is requested. These memory areas are not contiguous to the heap memory initially allocated at the startup. For projects allocating a lot of memory in the heap, heap scanning can have a considerable overhead.
* If you are compiling without optimisation (e.g. -O0), `GC_SCAN_ALL_MEMORY` or `GC_SCAN_ALL_MEMORY_EXCEPT_HEAPS` is enough. If you compile with optimisations, it's better to use a more conservative approach and allow the garbage collector to scan the registers too with `GC_SCAN_EVERYTHING` or `GC_SCAN_EVERYTHING_EXCEPT_HEAPS`. Optimised functions may not push all the local variables on the stack and the collector may free pointers prematurely, because they are not found on the stack.
* The GC scans only the allocated regions of the heap, even if `GC_SCAN_HEAPS` is not set. The scan is limited to the size of the allocations made via `gc_alloc`. Enabling `GC_SCAN_HEAPS` may prevent the collection of circular references, as objects in the heap may keep each other alive. For most applications, it is recommended to use either `GC_SCAN_ALL_MEMORY_EXCEPT_HEAPS` or `GC_SCAN_EVERYTHING_EXCEPT_HEAPS`. Furthermore, avoiding to scan the regions of the heap entirely leads also to a gain in performance.

### Function Reference

| Function | Signature | Description |
|----------|-----------|-------------|
| `gc_state* gc_init(uint8_t flags);` | `flags` — bitmask specifying which memory regions to scan | Initialises a new garbage collector instance. Returns a pointer to `gc_state`. |
| `void gc_destroy(gc_state*);` | `state` — GC instance | Cleans up and frees the GC state, including all tracked allocations. |
| `void* gc_alloc(gc_state*, size_t, bool);` | `state` — GC instance<br>`size` — number of bytes<br>`zero` — if true, memory is zeroed | Allocates memory tracked by the GC. Optionally zero-initializes it. |
| `void* gc_realloc(gc_state*, void*, size_t);` | `state` — GC instance<br>`ptr` — previously allocated pointer<br>`size` — new size | Resizes a previously GC-allocated memory block. |
| `void gc_free(gc_state*, void*);` | `state` — GC instance<br>`ptr` — allocated pointer | Manually frees a GC-tracked memory block. Optional, as the collector can reclaim it automatically. |
| `void gc_collect(state)` | `state` — GC instance | Macro that first saves registers, then calls `_gc_collect()` to perform _mark and sweep_ operations. |
| `void* gc_current_stack_top();` | — | Returns the current top of the stack for the running thread. |
| `void gc_mark(gc_state*, void*, void*, bool);` | `state` — GC instance<br>`start` — memory start pointer<br>`end` — memory end pointer<br>`reachable` — mark as reachable or not | Marks a memory range as reachable during the mark phase. |
| `void gc_sweep(gc_state*);` | `state` — GC instance | Sweeps through all tracked allocations and frees unreachable blocks. |
| `void* gc_stack_base();` | — | Returns the base (bottom) of the stack. |
| `void gc_data_section(void**, void**);` | `start` and `end` pointers to data section | Populates start/end addresses of the `.data` section. |
| `void gc_bss_section(void**, void**);` | `start` and `end` pointers to BSS section | Populates start/end addresses of the `.bss` section. |
| `memory_region* gc_heap_regions(size_t*);` | `count` — returns number of heap regions | Returns an array of memory regions representing the heap(s) for scanning. |
| `gc_print_state(gc_state *)` | `state` — GC instance | Print a table with current allocations managed by the GC. |

#### Notes

* It is not required to call `gc_collect` manually, unless you want to trigger garbage collection at a specific point. The collector is automatically invoked after a certain number of allocations, defined by the macro `GC_ALLOC_THRESHOLD`.
* If you want a more aggressive or relaxed collection policy, you can adjust the threshold in the GC state:

````c
state->threshold = 32;   // very aggressive: collect more often
state->threshold = 512;  // more relaxed: collect less often
````

## Example

Below is a simple example showing how to include and use the garbage collector in your own C project.

### Example Code (`example.c`)

````c
#include <stdio.h>
#include "gc.h"

int main() {
    // Initialize the GC to scan stack, heap, and globals
    gc_state* state = gc_init(GC_SCAN_ALL_MEMORY_EXCEPT_HEAPS);

    // Allocate some memory
    int* numbers = gc_alloc(state, 10 * sizeof(int), true);

    // Fill array
    for (int i = 0; i < 10; i++) {
        numbers[i] = i * i;
    }

    // Print the values
    for (int i = 0; i < 10; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    // Optional: manually trigger garbage collection
    gc_collect(state);

    // Destroy GC state
    gc_destroy(state);

    return 0;
}
````

### Compile with Static Library
Compile your program linking against the static library:

````bash
$ gcc -o example_static example.c ./libgc.a -lpthread
````

Then, run the program:

````bash
./example_static
````

### Compile with Shared Library

Compile your program linking against the shared library:

````bash
$ gcc -o example_shared example.c -L. -lgc -lpthread
````
Ensure the shared library is found at runtime:

````bash
export LD_LIBRARY_PATH=$(pwd):$LD_LIBRARY_PATH
````

Then, run the program:

````bash
./example_shared
````

#### Notes
* The `-lpthread` flag is required on Linux to enable stack scanning with pthreads. You don't need it if you compile on macOS.
* On macOS, replace `LD_LIBRARY_PATH` with `DYLD_LIBRARY_PATH`.

## Contributing

Contributions are welcome! This project is still relatively small and untested on some platforms, so any help is appreciated. Here are some ways you can contribute:

* **Bug Reports:** If you encounter any issues or crashes, please open an issue on GitHub with details about your OS, architecture, and steps to reproduce the problem.  

* **Feature Requests:** Suggestions for new features, optimisations, or improved portability are welcome.  

* **Code Contributions:**  
  - Fix bugs, improve performance, or add support for untested platforms (e.g., Windows, FreeBSD).  
  - Enhance thread-safety for multithreaded applications.  
  - When submitting a pull request, ensure your code is properly formatted, documented, and tested.  

* **Documentation:** Improvements to this README or inline documentation are encouraged. Clear examples, explanations, or diagrams are especially helpful.  

> Please make sure all contributions are compatible with the **GPLv3 license**.


## Final Remarks

* **Windows Support:** This garbage collector has **not been tested on Windows**, and it likely will not work out of the box on that platform. If you try it on Windows, please let me know whether it works. If you fix any issues, contributions via pull request are very welcome!  

* **Other Unix-like OSes:** It **may or may not work** on other Unix-like systems (e.g., FreeBSD, OpenBSD). If you try it on these platforms and it works—or if you make improvements—your contributions are highly appreciated.  


* **Multithreading:** The library has **not been tested in multithreaded applications**. It can work with multiple threads, but careful consideration is required:
  - Each thread has its own stack, so `gc_init()` should be aware of stack regions for all threads you want to scan.
  - Allocations are tracked globally, so access to the GC state may require locking (e.g., mutexes) to prevent race conditions.
  - Manual calls to `gc_collect()` from multiple threads should be synchronized to avoid conflicts during mark-and-sweep.

> Use in multithreaded programs at your own discretion, and contributions to improve thread safety are welcome.

## License

This project is licensed under the **GNU General Public License v3.0 (GPL-3.0)**.  

You are free to use, modify, and redistribute this code under the terms of the GPL. A copy of the license can be found at [https://www.gnu.org/licenses/gpl-3.0.en.html](https://www.gnu.org/licenses/gpl-3.0.en.html).  

> **Note:** If you incorporate this code into other projects, make sure that the resulting project complies with the GPLv3 terms.


